
Я сейчас пилю новую концепцию реактивности для реатома, вкратце я называю это фьючерсами, но там все намного сложнее, на самом деле.

Главная новая фишка - это транзакция, которая похожа на диспатч, но в деталях сильно отличается.

Транзакция - это контейнер который содержит пайплайн зависимых операций - назовем их тасками, сортирует их топологически и выполняет синхронно или асинхронно. 

```const fetchData = future(
  // task 1 
  (options) => fetch(`/…`, {body: options})
).chain(
  // task 2  
  resp => resp.json()
)
// now you can do this:
fetchData.subscribe(data => render(data))```
Вызов fetchData (`fetchData(options)`) вернет промис который зарезолвится ответом фетча, но под капотом там создается транзакция, которая в более сложных кейсах делает некоторую магию.

Одна иp главных отличительных особенностей транзакции - rollback/s. Работает так: каждая таска пайплайна может помимо резльтата вернуть еще и rollback, который будет выполнен в случае фейла транзакции. Транзакция считается failed если какая-то таска выбросила исключение И (обязательно) на эту таску или ее чейны есть подписчики (subscribers)- сайд-эффекты.

Вообще я переосмысливаю понятие сайд-эффектов и утверждаю что сайд-эффект - это все, результат чего нельзя отменить. Даже если в таске мы вызываем какой-то фетч на бекенд, мы можем вернуть rollback который вызывает другой фетч на отмену операции. Понятно что это немного идиалистическая концепция, но она показалась мне хорошим балансом простоты и эффективности.

Но на практике я встретился с таким кейсом: транзакция фейлится из-за какой-то таски, у этой таски есть подписчик и транзакция фейлится тоже, но так же на этой таске весит следующая таска через catch и я ожидаю что она отработает, т.к. это часть бинес логики. Если бы на зафейленой таске не было подписчика - все было бы ок, но он там есть и транзакция зафейлилась и я прекращаю обработку всех следующих тасок. Видимо, это не верно, и нужно продолжать обрабатывать следующие таски, но только catch типа. И, логично, что таски которые зависят от catch тоже нужно обрабатывать? И, логично, что и их подписчиков тоже нужно вызывать? Но транзакция зафейлилась же..? Вот я и думаю, сама концепция в корне не верная или что-то как-то еще можно подправить?

Вот пример:
```const fetchData = (() => api.get(‘…’))

fetchData
  .subscribe()

fetchData
  .chain(someSelector)
  .catch(() => fallback)
  .subscribe(render2)```

Идея в том что если someSelector падает с ошибкой и никаких catch нет, то не нужно вызывать никаких подписчиков, потому что мы не знаем что делают подписчики и какие коллизии могут быть, если одних подписчиков вызывать, а других не вызывать. Но тут catch есть

---

- подписки, после завершения транзакции, вызываются только у тех нод, которые не выполнили rollback
- вызов роллбека сетит в пайлоад своей ноды ошибку, вызвавшую роллбек
- стоит ли вызывать catch ноду, зависимую от роллбечной ноды, если через эту catch ноду уже прошли? (думаю да)
